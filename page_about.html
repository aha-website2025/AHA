<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>About - Affordable Housing Atlas</title>
  <link rel="stylesheet" href="css_style.css">
  <style>
    #grid-container {
      position: relative;
    }

    /* About page specific flip card overrides */
    .model-page .flip-card .flip-back {
      background-color: #000000;
      cursor: pointer;
    }

    .model-page .flip-card .flip-back p {
      font-weight: bold;
      font-size: 1rem;
      color: #ffffff;
    }

    /* Bio Popup Styles */
    .bio-popup-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    }

    .bio-popup-overlay.active {
      display: flex;
    }

    .bio-popup-content {
      background-color: #000000;
      color: #ffffff;
      padding: 3rem;
      max-width: 600px;
      width: 80%;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
      box-sizing: border-box;
    }

    .bio-close-btn {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: none;
      border: none;
      color: #ffffff;
      font-size: 2rem;
      cursor: pointer;
      line-height: 1;
      padding: 0;
      width: 30px;
      height: 30px;
    }

    .bio-close-btn:hover {
      opacity: 0.7;
    }

    .bio-popup-content h2 {
      margin: 0 0 1.5rem 0;
      font-size: 1.5rem;
      font-weight: bold;
      color: #ffffff;
    }

    .bio-popup-content #bioText {
      line-height: 1.6;
      font-size: 1rem;
    }

    .bio-popup-content #bioText p {
      margin-bottom: 1rem;
    }
  </style>
</head>
<body class="model-page">

  <header class="site-header">
    <a href="index.html">
      <img src="graphics/Logo.png" alt="Affordable Housing Atlas Logo" class="logo" />
    </a>
  </header>

  <nav class="menu">
    <div class="hamburger black" onclick="toggleMenu()">
      <span></span><span></span><span></span>
    </div>
    <ul class="menu-items" id="menuItems">
      <li><a href="index.html">Projects</a></li>
      <li><a href="page_models.html">Models</a></li>
      <li><a href="page_map.html">Map</a></li>
      <li><a href="page_about.html">About</a></li>
    </ul>
  </nav>

  <main>
    <div id="grid-container">
      <div class="grid">
        <!-- Row 1 -->
        <div class="tile title" style="grid-column: 1 / 2; grid-row: 1;">ABOUT</div>
        <div class="tile blank" style="grid-column: 2 / 3; grid-row: 1;"></div>
        <div class="description" id="about-description" style="grid-column: 3 / 5; grid-row: 1; max-height: 100%; overflow-y: auto;">
          <!-- Content will be loaded from about/about.txt -->
        </div>
        
        <!-- Row 2 -->
        <div class="tile text-left" style="grid-column: 1 / 2; grid-row: 2; justify-content: center; align-items: center;">
          <p style="text-align: center; width: 100%; line-height: 1.2;"><strong style="color: #4a4a4a;">Contact:</strong><br><br>affordablehousingatlas<br>@gmail.com</p>
        </div>
        <div class="tile flip-card" style="grid-column: 2 / 3; grid-row: 2;">
          <div class="flip-inner">
            <div class="flip-front">
              <img src="about/SD.jpg" alt="SD" />
            </div>
            <div class="flip-back" onclick="openBioPopup('about/SD.md', 'Dr. Sascha Delz')">
              <p>Dr. Sascha Delz</p>
            </div>
          </div>
        </div>
        <div class="tile hatch" style="grid-column: 3 / 4; grid-row: 2;"></div>
        <div class="tile flip-card" style="grid-column: 4 / 5; grid-row: 2;">
          <div class="flip-inner">
            <div class="flip-front">
              <img src="about/GS.jpg" alt="GS" />
            </div>
            <div class="flip-back" onclick="openBioPopup('about/GS.txt', 'Gio Shin')">
              <p>Gio Shin</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Bio Popup -->
  <div id="bioPopup" class="bio-popup-overlay">
    <div class="bio-popup-content">
      <button class="bio-close-btn" onclick="closeBioPopup()">Ã—</button>
      <h2 id="bioName"></h2>
      <div id="bioText"></div>
    </div>
  </div>

  <script>
    function toggleMenu() {
      const menu = document.getElementById("menuItems");
      menu.style.display = menu.style.display === "block" ? "none" : "block";
    }

    // Simple markdown parser for basic formatting
    function parseMarkdown(text) {
      // Convert bold FIRST (to avoid conflicts with italic): **text** or __text__ to <strong>text</strong>
      text = text.replace(/\*\*(.+?)\*\*/gs, '<strong>$1</strong>');
      text = text.replace(/__(.+?)__/gs, '<strong>$1</strong>');
      
      // Convert italic: *text* or _text_ to <em>text</em>
      text = text.replace(/\*(.+?)\*/gs, '<em>$1</em>');
      text = text.replace(/_(.+?)_/gs, '<em>$1</em>');
      
      return text;
    }

    // Bio Popup Functions
    async function openBioPopup(txtFile, name) {
      try {
        const response = await fetch(txtFile);
        const text = await response.text();
        
        console.log('Loaded text:', text);
        
        document.getElementById('bioName').textContent = name;
        
        // Split by double newlines to create paragraphs
        const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim());
        console.log('Paragraphs:', paragraphs);
        
        const processedHTML = paragraphs.map(p => {
          const processed = parseMarkdown(p.trim());
          console.log('Original:', p.trim());
          console.log('Processed:', processed);
          return `<p>${processed}</p>`;
        }).join('');
        
        console.log('Final HTML:', processedHTML);
        document.getElementById('bioText').innerHTML = processedHTML;
        
        document.getElementById('bioPopup').classList.add('active');
        document.body.style.overflow = 'hidden'; // Prevent background scrolling
      } catch (error) {
        console.error('Error loading bio text:', error);
        document.getElementById('bioText').innerHTML = '<p>Content could not be loaded.</p>';
        document.getElementById('bioPopup').classList.add('active');
      }
    }

    function closeBioPopup() {
      document.getElementById('bioPopup').classList.remove('active');
      document.body.style.overflow = ''; // Restore scrolling
    }

    // Close popup when clicking outside the content
    document.getElementById('bioPopup').addEventListener('click', function(e) {
      if (e.target === this) {
        closeBioPopup();
      }
    });

    // Load about text from file
    async function loadAboutText() {
      try {
        const response = await fetch('about/about.txt');
        const text = await response.text();
        const descriptionDiv = document.getElementById('about-description');
        
        // Split by double newlines to create paragraphs
        const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim());
        descriptionDiv.innerHTML = paragraphs.map(p => `<p>${p.trim()}</p>`).join('');
        
        // Redraw lines after content is loaded
        setTimeout(() => {
          drawDashedLinesBetweenTileRows();
          drawVerticalDashedLines();
        }, 100);
      } catch (error) {
        console.error('Error loading about text:', error);
        document.getElementById('about-description').innerHTML = '<p>Content could not be loaded.</p>';
      }
    }

    // Load content on page load
    loadAboutText();

    // Draw horizontal dashed lines between rows
    function drawDashedLinesBetweenTileRows() {
      const tiles = Array.from(document.querySelectorAll('.tile, .description'));
      if (tiles.length === 0) return;

      // Remove any existing horizontal lines
      document.querySelectorAll('.horizontal-dashed-line').forEach(line => line.remove());

      const rowThreshold = 10; // Allow up to 10px difference in top values to group tiles in same row
      const rows = [];

      // Group tiles into rows based on vertical position (within threshold)
      tiles.forEach(tile => {
        const rect = tile.getBoundingClientRect();
        const top = rect.top;

        let foundRow = false;
        for (let row of rows) {
          if (Math.abs(row.top - top) < rowThreshold) {
            row.tiles.push(tile);
            foundRow = true;
            break;
          }
        }

        if (!foundRow) {
          rows.push({ top, tiles: [tile] });
        }
      });

      // Sort rows by top position
      rows.sort((a, b) => a.top - b.top);

      // Compute max horizontal span across all rows
      let maxLeft = Infinity;
      let maxRight = -Infinity;

      rows.forEach(row => {
        row.tiles.forEach(tile => {
          const rect = tile.getBoundingClientRect();
          maxLeft = Math.min(maxLeft, rect.left);
          maxRight = Math.max(maxRight, rect.right);
        });
      });

      const totalLineWidth = maxRight - maxLeft;
      const container = document.getElementById("grid-container");
      const containerRect = container.getBoundingClientRect();

      // Draw lines between each row
      for (let i = 0; i < rows.length - 1; i++) {
        const row1 = rows[i];
        const row2 = rows[i + 1];

        const rect1 = row1.tiles[0].getBoundingClientRect();
        const rect2 = row2.tiles[0].getBoundingClientRect();

        const bottom = rect1.bottom;
        const top = rect2.top;

        const middleY = (bottom + top) / 2;

        const line = document.createElement('div');
        line.className = 'horizontal-dashed-line';
        line.style.position = 'absolute';
        line.style.left = `${maxLeft - containerRect.left}px`;
        line.style.top = `${middleY - containerRect.top}px`;
        line.style.width = `${totalLineWidth}px`;
        line.style.height = '1px';
        line.style.backgroundImage = `repeating-linear-gradient(
          to right,
          #ccc 0,
          #ccc 4px,
          transparent 5px,
          transparent 9px
        )`;
        line.style.pointerEvents = 'none';
        line.style.zIndex = '10';

        container.appendChild(line);
      }
    }

    // Draw vertical dashed lines between columns
    function drawVerticalDashedLines() {
      const container = document.getElementById("grid-container");
      if (!container) return;

      // Remove old lines
      document.querySelectorAll(".vertical-grid-line").forEach(line => line.remove());

      const tiles = Array.from(container.querySelectorAll(".tile, .description")).filter(el => el.offsetParent !== null);
      if (tiles.length === 0) return;

      // Group by column (left edge)
      const columns = new Map();
      tiles.forEach(tile => {
        const r = tile.getBoundingClientRect();
        const left = Math.round(r.left + window.scrollX);
        if (!columns.has(left)) columns.set(left, { rects: [], width: r.width });
        columns.get(left).rects.push(r);
      });

      const colList = [...columns.entries()]
        .sort((a, b) => a[0] - b[0])
        .map(([left, info]) => {
          const tops = info.rects.map(rr => rr.top + window.scrollY);
          const bottoms = info.rects.map(rr => rr.bottom + window.scrollY);
          return {
            left,
            width: info.width,
            topMin: Math.min(...tops),
            bottomMax: Math.max(...bottoms)
          };
        });

      if (colList.length < 2) return;

      const topEdge = Math.min(...colList.map(c => c.topMin));

      // Calculate tile width and gap from first two columns
      const tileWidth = colList[0].width;
      const firstColRight = colList[0].left + colList[0].width;
      const secondColLeft = colList[1].left;
      const gap = secondColLeft - firstColRight;
      
      // Position of first divider (midway between columns 1 and 2)
      const firstDividerX = firstColRight + (gap / 2);
      
      // Increment for each subsequent divider (tile width + gap)
      const increment = tileWidth + gap;

      for (let i = 0; i < colList.length - 1; i++) {
        const c1 = colList[i];
        const c2 = colList[i + 1];

        // Calculate X position: first divider + (i * increment)
        const midX = firstDividerX + (i * increment);

        // Use the TALLER of the two columns
        const bottomEdgeForDivider = Math.max(c1.bottomMax, c2.bottomMax);

        const h = bottomEdgeForDivider - topEdge;
        if (h <= 0) continue;

        const line = document.createElement("div");
        line.className = "vertical-grid-line";
        line.style.position = "absolute";
        line.style.top = `${topEdge - 15}px`;
        line.style.left = `${midX}px`;
        line.style.height = `${h + 30}px`;
        line.style.width = "1px";
        line.style.backgroundImage =
          "repeating-linear-gradient(to bottom, #ccc 0, #ccc 4px, transparent 5px, transparent 9px)";
        line.style.pointerEvents = "none";
        line.style.zIndex = "1";

        document.body.appendChild(line);
      }
    }

    // Draw lines after page loads
    window.addEventListener('load', () => {
      setTimeout(() => {
        drawDashedLinesBetweenTileRows();
        drawVerticalDashedLines();
      }, 100);
    });

    // Redraw on window resize
    window.addEventListener('resize', () => {
      // Remove existing dashed lines
      document.querySelectorAll(".vertical-grid-line, .horizontal-grid-line").forEach(line => line.remove());
      
      // Redraw
      drawDashedLinesBetweenTileRows();
      drawVerticalDashedLines();
    });
  </script>
</body>
</html>
